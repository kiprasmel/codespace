#!/usr/bin/env bash

set -euo pipefail

test -z "${DEBUG:-}" || set -x

HELP="\
Usage:
codespace <branch> [base]
codespace <branch> [base] [--clone [clone_url]]
codespace <sub-command>

  <branch>  can be existing (won't modify), or new (will create).
  [base]    is where the <branch> will point to (if creating a new one).
            [base] defaults to symbolic-ref of remote HEAD.

optional flags:
  --clone [clone_url]
            create a standalone clone instead of a worktree.
            benefits: allows other checkouts/rebases in main repo,
            better for one-off initialization on remote systems.
            [clone_url] - inferred from remote if inside a git repo.


env vars:
  GUI_EDITOR or EDITOR  - for opening a newly created codespace in an editor.

  CODESPACE_CONFIG_ROOT - dir where configs for codespaces are placed.
                          used to configure post-create scripts, link hidden files, etc.
                          layout of the dir should be: \"/org/repo/\" (see also base-repo).
                          inside:
                            - files, scripts, etc that are not in the repo itself.
                            - \".codespace/post-create\" script - ran on codespace creation.

  DEBUG                 - if set, prints every command executed.


.git files:
  CODESPACE_IS_CLONE    - marker file created in .git/ when using 'create' with '--clone'.


sub-commands:
  c, create    <branch> [base]  - same as no sub-command (see above).
  post-create  [cs_path]        - run the post-create script for a given codespace.
                                  [cs_path] defaults to codespace inside cwd.
  rm, remove   <branch|path>    - remove a codespace (worktree or clone).
                                  checks for uncommitted/unpushed changes before removing.
                                  [-f, --force] - ignore safety checks.
  config                         - absolute path the config dir of the repo (\"\$CODESPACE_CONFIG_ROOT/repo-id\")
  config init                    - initialize config dir + post-create script for the current repo.
  repo-id      [rel_to]         - get the repo ID to locate appropriate config location
                                  in \"\$CODESPACE_CONFIG_ROOT\".
                                  assumes that repositories are placed in \"\$HOME/org/repo\"
                                  (controllable via [rel_to], which defaults to \"\$HOME\").
                                  extracts \"/org/repo\" portion of \"\$PWD\" wrt [rel_to].
  base-repo                     - absolute path to the root of the base repository.
  cleanpath    <string>         - sanitize path for worktree dir (replace /, :, spaces etc)
  is-checkout-not-worktree      - prints 1 if we are in a branch checkout in the main repo, 0 otherwise
  hide         <file>...         - add file(s) to .git/info/exclude (local gitignore).
                                  note: affects not only the worktree, but the base repo.
"

main() {
	test $# -ge 1 || {
		>&2 echo "$HELP"
		exit 1
	}

	cmd="$1"
	shift

	while [ $# -ge 0 ]; do
		case "$cmd" in
			c|create) cs_create_open "$@"; break ;;
			post-create) cs_post_create "$@"; break ;;
			post-create.link-files-from-repo) cs_post_create__link_files_from_repo "$@"; break ;;
			post-create.link-files-from-config) cs_post_create__link_files_from_config "$@"; break ;;
			rm|remove) cs_remove "$@"; break ;;
			base-repo) cs_abs_path_base_repo "$@"; break ;;
			repo-id) cs_repo_id "$@"; break ;;
			config)
				if [ $# -ge 1 ] && [ "$1" = "init" ]; then
					shift
					cs_config_init "$@"
				else
					cs_config_path "$@"
				fi
				break ;;
			cleanpath) cs_cleanpath "$@"; break ;;
			is-checkout-not-worktree) cs_are_we_in_checkout_not_worktree "$@"; break ;;
			hide) for f in "$@"; do cs_git_exclude_add "$f"; done; break ;;
			-h|--help) echo "$HELP"; exit 0 ;;
			*) cs_create_open "$cmd" "$@"; break ;;
		esac
	done
}

cs_create_open() {
	branch="$1"

	# argv format (in order): <branch> [base] [--clone [clone_url]]
	if [ "${2:-}" = "--clone" ]; then
		# <branch> --clone [clone_url]
		WT_PATH="$(cs_create_via_clone "$branch" "${3:-}" | tail -n1)"
	elif [ "${3:-}" = "--clone" ]; then
		# <branch> [base] --clone [clone_url]
		WT_PATH="$(cs_create_via_clone "$branch" "${4:-}" | tail -n1)"
	else
		# <branch> [base] (worktree mode)
		WT_PATH="$(NO_POST_CREATE=1 cs_create_via_worktree "$branch" "${2:-}" | tail -n1)"
	fi

	GUI_EDITOR="${GUI_EDITOR:-$EDITOR}"

	if [ -n "$GUI_EDITOR" ]; then
		(unset GIT_DIR GIT_WORK_TREE; "$GUI_EDITOR" --new-window "$WT_PATH")
	else
		>&2 echo "neither \$GUI_EDITOR no \$EDITOR env var set, cannot open codespace with editor"
	fi

	echo "$WT_PATH"
	cs_post_create "$WT_PATH"
}

cs_create_via_worktree() {
	branch="$1"

	base="${2:-$(git default-branch-r 2>/dev/null)}"
	base="${base:-$(git symbolic-ref refs/remotes/origin/HEAD --short)}"

	test -n "$(git branch -l "$branch")" || git branch --no-track "$branch" "$base"
	path="$(cs_abs_path_from_repo_name_and_branch "$branch")"
	git worktree add "$path" "$branch"

	test -n "$NO_POST_CREATE" || cs_post_create "$path"
	
	echo "$path"
}

cs_create_via_clone() {
	branch="$1"

	# clone_url: provided arg takes precedence, otherwise fallback to inferring from remote
	if [ -n "${2:-}" ]; then
		clone_url="$2"
	else
		clone_url="$(git remote get-url origin 2>/dev/null)" || true
	fi

	test -n "$clone_url" || {
		>&2 echo "err: no clone URL provided, and cannot infer (not inside a git repository)"
		exit 1
	}

	repo_name="$(cs_repo_name_from_url "$clone_url")"

	# inside a git repo: clone to sibling dir; otherwise: clone to current dir
	if git rev-parse --git-dir >/dev/null 2>&1; then
		base_dir=".."
	else
		base_dir="."
	fi

	repo_path="$(cs_abspath "${base_dir}/$(cs_cleanpath "${repo_name}/${branch}")")"

	git clone "$clone_url" "$repo_path"
	(cd "$repo_path" && git checkout "$branch" 2>/dev/null || git checkout -b "$branch")

	# write marker file with repo name (not full repo-id)
	echo "$repo_name" > "$repo_path/.git/CODESPACE_IS_CLONE"

	# print path last, will be used in other functions
	echo "$repo_path"
}

cs_post_create() {
	WT_PATH="${1:-$(cs_abs_path_from_repo_name_and_branch)}"

	test -n "$CODESPACE_CONFIG_ROOT" || {
		>&2 echo "warn: env var '\$CODESPACE_CONFIG_ROOT' not set, cannot run post-create script"
		return 0
	}

	cd "$WT_PATH"

	POST_CREATE_CMD_PATH="$(cs_config_path)/.codespace/post-create"
	if [ -f "$POST_CREATE_CMD_PATH" ]; then
		BASE_REPO_PATH="$(cs_abs_path_base_repo)"

		if [ "$(cs_are_we_in_checkout_not_worktree)" = "1" ]; then
			# we are NOT in a worktree; we're in the main repository, and just checked out the branch
			>&2 echo "note: you are in branch checkout, not in a worktree. post-create script will behave differently."
			(ARE_WE_IN_CHECKOUT_NOT_WORKTREE=1 "$POST_CREATE_CMD_PATH" "$BASE_REPO_PATH")
		else
			("$POST_CREATE_CMD_PATH" "$BASE_REPO_PATH")
		fi

	else
		>&2 echo "warn: 'post-create' script not found in '$POST_CREATE_CMD_PATH', cannot run it"
	fi
}

cs_are_we_in_checkout_not_worktree() {
	GIT_DIR="$(realpath "$(git rev-parse --git-dir)")"
	GIT_COMMON_DIR="$(realpath "$(git rev-parse --git-common-dir)")"
	test "$GIT_DIR" = "$GIT_COMMON_DIR" && echo 1 || echo 0
}

cs_repo_id() {
	rel_to="${1:-$HOME}"
	if [ -n "$(cs_clone_marker)" ]; then
		cs_repo_id_of_clone --relative-to="$rel_to"
	else
		cs_abs_path_base_repo --relative-to="$rel_to"
	fi
}

cs_abs_path_base_repo() {
	realpath "$(git rev-parse --git-common-dir)/.." "$@"
}

cs_repo_id_of_clone() {
	clone_repo_name="$(cs_clone_marker)"
	realpath "$(pwd)/../$clone_repo_name" "$@"
}

cs_clone_marker() {
	MARKER_PATH="$(cs_clone_marker_path "${1:-}")"
	test -f "$MARKER_PATH" && cat "$MARKER_PATH"
}

cs_clone_marker_path() {
	if [ -n "${1:-}" ]; then
		echo "$1/.git/CODESPACE_IS_CLONE"
	else
		echo "$(git rev-parse --git-dir 2>/dev/null)/CODESPACE_IS_CLONE"
	fi
}

cs_repo_name_from_url() {
	url="$1"
	# git@github.com:org/repo.git -> repo
	# https://github.com/org/repo.git -> repo
	basename "$url" .git
}

cs_abs_path_from_repo_name_and_branch() {
	branch="${1:-$(git branch --show-current)}"
	repo_name="$(basename "$(cs_abs_path_base_repo)")"
	path="$(cs_cleanpath "$repo_name/$branch")"
	cs_abspath "../$path"
}

cs_cleanpath() {
	echo "$1" | tr '/: ' '_'
}

cs_abspath() {
	# cd "$1" && pwd
	realpath "$1"
}


##################
#                #
#  BEGIN REMOVE  #
#                #
##################

cs_remove() {
	force=""
	arg=""
	for a in "$@"; do
		case "$a" in
			-f|--force) force=1 ;;
			*) arg="$a" ;;
		esac
	done

	test -n "$arg" || {
		>&2 echo "err: missing <branch|path> argument"
		>&2 echo "usage: codespace remove <branch|path> [-f]"
		exit 1
	}

	# first try as branch name, then as direct path
	path_from_branch="$(cs_abs_path_from_repo_name_and_branch "$arg")"
	if [ -d "$path_from_branch" ]; then
		cs_path="$path_from_branch"
	elif [ -d "$arg" ]; then
		cs_path="$(cs_abspath "$arg")"
	else
		>&2 echo "err: codespace not found"
		>&2 echo "  tried branch '$arg': $path_from_branch"
		>&2 echo "  tried path '$arg': not a directory"
		exit 1
	fi

	# check if it's a clone or worktree
	if [ -f "$(cs_clone_marker_path "$cs_path")" ]; then
		cs_remove_clone "$cs_path" "$force"
	else
		cs_remove_worktree "$cs_path" "$force"
	fi
}

cs_remove_safety_check() {
	cs_path="$1"

	(
		cd "$cs_path"

		# check for uncommitted changes
		if ! git diff --quiet HEAD 2>/dev/null; then
			>&2 echo "err: uncommitted changes in $cs_path"
			>&2 echo "commit or stash changes before removing, or manually delete with: rm -rf \"$cs_path\""
			exit 1
		fi

		# check for untracked files (excluding ignored)
		if [ -n "$(git ls-files --others --exclude-standard)" ]; then
			>&2 echo "err: untracked files in $cs_path"
			>&2 echo "remove or commit them before removing, or manually delete with: rm -rf \"$cs_path\""
			exit 1
		fi

		# check for unpushed commits on current branch
		current_branch="$(git branch --show-current)"
		if [ -n "$current_branch" ]; then
			upstream="$(git rev-parse --abbrev-ref "@{upstream}" 2>/dev/null)" || true
			if [ -n "$upstream" ]; then
				unpushed="$(git log "$upstream..HEAD" --oneline 2>/dev/null)"
				if [ -n "$unpushed" ]; then
					>&2 echo "err: unpushed commits on branch '$current_branch' in $cs_path"
					>&2 echo "push changes before removing, or manually delete with: rm -rf \"$cs_path\""
					exit 1
				fi
			else
				# no upstream set - check if branch exists on any remote
				if ! git ls-remote --exit-code --heads origin "$current_branch" >/dev/null 2>&1; then
					>&2 echo "err: branch '$current_branch' has no remote tracking and doesn't exist on origin"
					>&2 echo "push the branch before removing, or manually delete with: rm -rf \"$cs_path\""
					exit 1
				fi
			fi
		fi
	)
}

cs_remove_worktree() {
	cs_path="$1"
	force="${2:-}"

	if [ -n "$force" ]; then
		git worktree remove --force "$cs_path"
	else
		cs_remove_safety_check "$cs_path"
		git worktree remove "$cs_path"
	fi
}

cs_remove_clone() {
	cs_path="$1"
	force="${2:-}"

	test -n "$force" || cs_remove_safety_check "$cs_path"
	rm -rf "$cs_path"
	>&2 echo "removed clone: $cs_path"
}

################
#              #
#  END REMOVE  #
#              #
################



##################
#                #
#  BEGIN CONFIG  #
#                #
##################

cs_config_init() {
	test -n "$CODESPACE_CONFIG_ROOT" || {
		>&2 echo "err: env var '\$CODESPACE_CONFIG_ROOT' not set, cannot initialize config"
		exit 1
	}

	CONFIG_PATH="$(cs_config_path)"

	if [ -d "$CONFIG_PATH" ]; then
		>&2 echo "Config directory already exists at: $CONFIG_PATH"
		exit 0
	fi

	CODESPACE_PATH="$CONFIG_PATH/.codespace"
	POST_CREATE_PATH="$CODESPACE_PATH/post-create"

	mkdir -p "$CODESPACE_PATH"

	echo "$POST_CREATE_SCRIPT_TEMPLATE" > "$POST_CREATE_PATH"
	chmod +x "$POST_CREATE_PATH"

	echo "config path: $CONFIG_PATH"
	echo "post-create script path: $POST_CREATE_PATH"
}

POST_CREATE_SCRIPT_TEMPLATE='\
#!/usr/bin/env bash

set -xeuo pipefail

REPO_FILES=".env"
LAYER2_FILES="AGENTS.md"

codespace post-create.link-files-from-repo $REPO_FILES
codespace post-create.link-files-from-config $LAYER2_FILES

# .. repo setup scripts ..
'

cs_config_path() {
	echo "$CODESPACE_CONFIG_ROOT/$(cs_repo_id)"
}

################
#              #
#  END CONFIG  #
#              #
################



###############
#             #
#  BEGIN LIB  #
#             #
###############

# expose convenience functions to be used in config scripts
cs_post_create__link_files_from_repo() {
	# skip if clone mode (no base repo to link from)
	if [ -n "$(cs_clone_marker)" ]; then
		>&2 echo "warn: skipping link-files-from-repo in clone mode (no local base repo)"
		return 0
	fi

	BASE_REPO_DIR="$(cs_abs_path_base_repo)"

	# skip if we are in a checkout
	# (we're already in the repo - we would link from ourselves to ourselves)
	test "$(cs_are_we_in_checkout_not_worktree)" = "1" && return

	for file in "$@"; do
		ln -s "$BASE_REPO_DIR/$file" "./$file" || :
	done
}
cs_post_create__link_files_from_config() {
	LAYER2_CONFIG_PATH="$(cs_config_path)"

	for file in "$@"; do
		ln -s "$LAYER2_CONFIG_PATH/$file" "./$file" || :
		cs_git_exclude_add "$file"
	done
}

# hide files from git
cs_git_exclude_add() {
	file="$1"
	exclude_file="$(git rev-parse --git-common-dir)/info/exclude"

	# add to exclude if not already present (exact line match)
	if ! grep -qxF "$file" "$exclude_file"; then
		echo "$file" >> "$exclude_file"
	fi
}

#############
#           #
#  END LIB  #
#           #
#############


main "$@"
exit $?
