#!/usr/bin/env bash

set -euo pipefail

DIRNAME="$(dirname "$(realpath "$0")")"

# shellcheck source=codespace-utils
source "$DIRNAME/codespace-utils"

# auto-detect agent environments and disable interactive prompts
test -n "${CS_NO_INTERACTIVE:-}" || {
	test -n "${CURSOR_AGENT:-}" || test -n "${CI:-}" && {
		export CS_NO_INTERACTIVE=1
	}
}

# codespace-stack: multi-repo codespace management

REPO_VALUES_INFO="\
- repo names (siblings in org directory)
- clone URLs
- objects: { \"name\": \"repo\", \"cloneURL\": \"url\" }"

STACK_HELP="\
Usage:
codespace stack [create] <branch> [-s stack_name] [--clone|--worktree]
codespace stack init

sub-commands:
  init           create a stacks.json configuration file in the appropriate location.

args:
  <branch>       branch name to create across all repos in the stack.

flags:
  -s, --stack <stack_name>
                 stack name from stacks.json (default: \"default\").

mode flags:
  --clone        force clone mode (fresh clones for all repos).
  --worktree     force worktree mode (create worktrees from local repos).

env vars:
  CS_STACK_DEFAULT_CREATE_MODE
                 default creation mode: \"worktree\" (default) or \"clone\".
  CS_NO_INTERACTIVE
                 if set, skip interactive prompts and use defaults.
                 inferred if CURSOR_AGENT, CI, other vars are set.

config:
  stacks.json    located in \$CODESPACE_CONFIG_ROOT/<org>/stacks.json
                 format: { \"version\": \"0\", \"stacks\": { \"stack-id\": [\"repo1\", \"repo2\"] } }
                 repo values:
$(echo "$REPO_VALUES_INFO" | sed 's/^/                   /')

examples:
  codespace stack init                   # create stacks.json config file
  codespace stack        feature-x       # create \"default\" stack, create branches \"feature-x\" in all repos of stack
  codespace stack create feature-x       # same as above
  codespace stack feature-x -s full      # create stack from definition \"stack-id-2\" in stacks.json
  codespace stack feature-x --clone      # create clones, instead of worktrees
"

cs_stack_main() {
	# handle help
	case "${1:-}" in
		-h|--help)
			echo "$STACK_HELP"
			exit 0
			;;
		"")
			>&2 echo "$STACK_HELP"
			exit 1
			;;
	esac

	# dispatch subcommands
	cmd="$1"
	shift

	case "$cmd" in
		create)
			cs_stack_create "$@"
			;;
		init)
			cs_stack_init "$@"
			;;
		init-repo)
			# internal subcommand used by cs_stack_create for parallel repo init
			cs_stack_init_repo "$@"
			;;
		*)
			# implied create
			cs_stack_create "$cmd" "$@"
			;;
	esac
}

# Parse and validate create arguments
# Sets globals: branch, stack_name, create_mode
cs_stack_create_parse_args() {
	branch=""
	stack_name="default"
	local mode_flag=""

	while [ $# -gt 0 ]; do
		case "$1" in
			-s)
				shift
				stack_name="${1:-}"
				test -n "$stack_name" || {
					>&2 echo "err: -s requires a stack name"
					exit 1
				}
				;;
			--clone)
				mode_flag="clone"
				;;
			--worktree)
				mode_flag="worktree"
				;;
			-*)
				>&2 echo "err: unknown option: $1"
				exit 1
				;;
			*)
				if [ -z "$branch" ]; then
					branch="$1"
				else
					>&2 echo "err: unexpected argument: $1"
					exit 1
				fi
				;;
		esac
		shift
	done

	test -n "$branch" || {
		>&2 echo "err: <branch> is required"
		>&2 echo "usage: codespace stack [create] <branch> [-s stack_name]"
		exit 1
	}

	# determine creation mode (priority: flag > env > default)
	if [ -n "$mode_flag" ]; then
		create_mode="$mode_flag"
	elif [ -n "${CS_STACK_DEFAULT_CREATE_MODE:-}" ]; then
		create_mode="$CS_STACK_DEFAULT_CREATE_MODE"
	else
		create_mode="worktree"
	fi
}

# Setup stack directory structure
# Uses globals: branch, org_dir
# Sets globals: stack_dir, logs_dir
cs_stack_create_setup_dirs() {
	stack_dir="$org_dir/stack_$(cs_cleanpath "$branch")"
	if [ -d "$stack_dir" ]; then
		>&2 echo "err: stack directory already exists: $stack_dir"
		exit 1
	fi
	mkdir -p "$stack_dir"

	logs_dir="$stack_dir/.stack-init-logs"
	mkdir -p "$logs_dir"
}

# Setup tmux session if available
# Uses globals: branch, logs_dir
# Sets globals: use_tmux, tmux_session
cs_stack_create_setup_tmux() {
	use_tmux=""
	tmux_session=""
	if [ -z "${CS_NO_INTERACTIVE:-}" ] && command -v tmux >/dev/null 2>&1; then
		use_tmux=1
		tmux_session="stack-init-$(cs_cleanpath "$branch")"
		tmux new-session -d -s "$tmux_session" -n "main" \
			"echo 'Stack init: $branch'; echo 'Logs: $logs_dir'; echo; tail -f /dev/null"
		>&2 echo "tmux session created: $tmux_session"
		>&2 echo "attach with: tmux attach -t $tmux_session"
	fi
	>&2 echo "logs: $logs_dir"
}

# Pre-parse all repos into arrays
# Args: $1 = repos (newline-separated JSON entries)
# Uses globals: stack_dir, org_dir
# Sets globals: repo_names[], repo_clone_urls[], repo_dests[], repo_base_repos[]
cs_stack_create_prepare_repos() {
	local repos="$1"

	repo_names=()
	repo_clone_urls=()
	repo_dests=()
	repo_base_repos=()

	while IFS= read -r repo_entry; do
		test -n "$repo_entry" || continue

		cs_stack_parse_repo_entry "$repo_entry"
		# repo_name and clone_url are set by cs_stack_parse_repo_entry

		local local_repo_name="$repo_name"
		local local_clone_url="$clone_url"
		local repo_dest="$stack_dir/$local_repo_name"
		local base_repo="$org_dir/$local_repo_name"

		# Resolve clone URL if needed (repo doesn't exist locally and no URL provided)
		if [ -z "$local_clone_url" ] && [ ! -d "$base_repo/.git" ]; then
			local_clone_url="$(cs_infer_clone_url "$local_repo_name" "$org_dir")" || {
				>&2 echo "err: repo '$local_repo_name' not found locally and couldn't infer clone URL"
				>&2 echo "options:"
				>&2 echo "  a) clone the repo: git clone <url> $base_repo"
				>&2 echo "  b) add clone URL to stacks.json"
				exit 1
			}
		fi

		repo_names+=("$local_repo_name")
		repo_clone_urls+=("$local_clone_url")
		repo_dests+=("$repo_dest")
		repo_base_repos+=("$base_repo")
	done <<< "$repos"
}

# Spawn parallel repo init jobs
# Uses globals: create_mode, repo_names[], repo_clone_urls[], repo_dests[],
#               repo_base_repos[], logs_dir, use_tmux, tmux_session, branch
# Sets globals: repo_pids[]
cs_stack_create_spawn_jobs() {
	>&2 echo "==> Initializing repos (${#repo_names[@]} repos, mode: $create_mode)..."

	repo_pids=()
	for i in "${!repo_names[@]}"; do
		local r_name="${repo_names[$i]}"
		local r_clone_url="${repo_clone_urls[$i]}"
		local r_dest="${repo_dests[$i]}"
		local r_base="${repo_base_repos[$i]}"
		local log_file="$logs_dir/$r_name.log"

		if [ -n "$use_tmux" ]; then
			# tmux mode: create window that runs full init and logs via tee
			tmux new-window -t "$tmux_session" -n "$r_name" \
				"bash -c '\"$DIRNAME/codespace-stack\" init-repo \"$create_mode\" \"$r_name\" \"$r_clone_url\" \"$r_dest\" \"$r_base\" \"$branch\" 2>&1 | tee \"$log_file\"'"
		else
			# no tmux: background job with file logging
			(
				"$DIRNAME/codespace-stack" init-repo "$create_mode" "$r_name" "$r_clone_url" "$r_dest" "$r_base" "$branch"
			) >"$log_file" 2>&1 &
			repo_pids+=($!)
		fi
	done
}

# Wait for jobs and print summary
# Uses globals: use_tmux, tmux_session, repo_names[], logs_dir, repo_pids[]
cs_stack_create_wait_and_summarize() {
	local failures=()
	if [ -n "$use_tmux" ]; then
		cs_stack_tmux_wait "$tmux_session" "${repo_names[@]}"
		# check logs for failures
		for i in "${!repo_names[@]}"; do
			local r_name="${repo_names[$i]}"
			local log_file="$logs_dir/$r_name.log"
			if [ -f "$log_file" ] && grep -qE "^(CLONE_FAILED|POST_CREATE_FAILED)$" "$log_file"; then
				failures+=("$r_name")
			fi
		done
	else
		for i in "${!repo_pids[@]}"; do
			local pid="${repo_pids[$i]}"
			local r_name="${repo_names[$i]}"
			if ! wait "$pid"; then
				failures+=("$r_name")
			fi
		done
	fi

	echo
	if [ ${#failures[@]} -gt 0 ]; then
		>&2 echo "==> Stack created with errors:"
		>&2 echo "    Failed repos: ${failures[*]}"
		>&2 echo "    Logs: $logs_dir"
		if [ -n "$use_tmux" ]; then
			>&2 echo "    tmux session: tmux attach -t $tmux_session"
		fi
	else
		>&2 echo "==> Stack created successfully"
		# clean up on success (unless DEBUG is set)
		if [ -z "${DEBUG:-}" ]; then
			rm -rf "$logs_dir"
			if [ -n "$use_tmux" ]; then
				tmux kill-session -t "$tmux_session" 2>/dev/null || true
			fi
		else
			>&2 echo "    Logs: $logs_dir"
			if [ -n "$use_tmux" ]; then
				>&2 echo "    tmux session: tmux attach -t $tmux_session"
			fi
		fi
	fi
}

# Open editor for the stack
# Uses globals: stack_dir
cs_stack_create_open_editor() {
	>&2 echo "==> Opening editor..."
	GUI_EDITOR="${GUI_EDITOR:-$EDITOR}"
	if [ -n "$GUI_EDITOR" ]; then
		(unset GIT_DIR GIT_WORK_TREE; "$GUI_EDITOR" --new-window "$stack_dir")
	else
		>&2 echo "warn: neither \$GUI_EDITOR nor \$EDITOR env var set, cannot open stack with editor"
	fi
}

cs_stack_create() {
	cs_stack_create_parse_args "$@"

	# find stacks.json config
	stacks_json="$(cs_stack_find_config)"

	# get repos for the stack
	repos="$(cs_stack_get_repos "$stack_name" "$stacks_json")"
	test -n "$repos" || {
		>&2 echo "err: stack '$stack_name' not found or empty in $stacks_json"
		exit 1
	}

	# determine org directory (where repos live)
	org_dir="$(cs_stack_get_org_dir)"

	cs_stack_create_setup_dirs
	cs_stack_create_setup_tmux
	cs_stack_create_prepare_repos "$repos"
	cs_stack_create_spawn_jobs
	cs_stack_create_open_editor
	cs_stack_create_wait_and_summarize

	echo "$stack_dir"
}

# Wait for tmux windows to complete
# Args: session_name, repo_names...
cs_stack_tmux_wait() {
	session="$1"
	shift

	# poll until all repo windows are closed
	while true; do
		remaining=0
		for r_name in "$@"; do
			if tmux list-windows -t "$session" -F '#{window_name}' 2>/dev/null | grep -qx "$r_name"; then
				remaining=$((remaining + 1))
			fi
		done
		[ "$remaining" -eq 0 ] && break
		sleep 1
	done
}

cs_stack_find_config() {
	test -n "${CODESPACE_CONFIG_ROOT:-}" || {
		>&2 echo "err: env var '\$CODESPACE_CONFIG_ROOT' not set"
		exit 1
	}

	start_dir="$(cs_stack_get_org_dir)"
	current_dir="$start_dir"
	levels_up=0

	while true; do
		rel_path="$(realpath "$current_dir" --relative-to="$HOME" 2>/dev/null)" || rel_path="$current_dir"
		config_path="$CODESPACE_CONFIG_ROOT/$rel_path/stacks.json"

		if [ -f "$config_path" ]; then
			# if we went more than 1 level up, ask for confirmation
			if [ "$levels_up" -gt 1 ]; then
				if [ -n "${CS_NO_INTERACTIVE:-}" ]; then
					>&2 echo "found stacks.json $levels_up levels up at: $config_path (auto-accepting, CS_NO_INTERACTIVE set)"
				else
					>&2 printf "found stacks.json $levels_up levels up at: $config_path. use? [y/n] "
					read -r answer </dev/tty
					case "$answer" in
						y|Y|yes|Yes) ;;
						*)
							>&2 echo "aborted"
							exit 1
							;;
					esac
				fi
			fi
			echo "$config_path"
			return 0
		fi

		# check if we've reached home or root
		if [ "$current_dir" = "$HOME" ] || [ "$current_dir" = "/" ]; then
			break
		fi

		current_dir="$(dirname "$current_dir")"
		levels_up=$((levels_up + 1))
	done

	>&2 echo "err: stacks.json not found"
	>&2 echo "searched from: $start_dir"
	>&2 echo "expected location: \$CODESPACE_CONFIG_ROOT/<org>/stacks.json"
	>&2 echo "hint: run 'codespace stack init' to create one"
	exit 1
}

cs_stack_init() {
	test -n "${CODESPACE_CONFIG_ROOT:-}" || {
		>&2 echo "err: env var '\$CODESPACE_CONFIG_ROOT' not set"
		exit 1
	}

	org_dir="$(cs_stack_get_org_dir)"
	rel_path="$(realpath "$org_dir" --relative-to="$HOME" 2>/dev/null)" || rel_path="$org_dir"
	config_dir="$CODESPACE_CONFIG_ROOT/$rel_path"
	config_path="$config_dir/stacks.json"

	if [ -f "$config_path" ]; then
		>&2 echo "stacks.json already exists at:"
		echo "$config_path"
		exit 0
	fi

	# discover repos in org directory for template
	repos_json="$(cs_stack_discover_repos "$org_dir")"

	mkdir -p "$config_dir"

	# create template stacks.json
	cat > "$config_path" << EOF
{
    "version": "0",
    "stacks": {
        "default": $repos_json
    }
}
EOF

	info="\
edit the file to configure your stacks:
  - \"default\" stack contains discovered repos from: $org_dir
  - add more stacks as needed
  - repo values can be:
$(echo "$REPO_VALUES_INFO" | sed 's/^/      /')

created stacks.json at:
$config_path\
"

	echo "$info"
}

# Discover repos in org directory and return as JSON array
cs_stack_discover_repos() {
	org_dir="$1"
	repos=""
	indent="            "  # 12 spaces for array items

	for dir in "$org_dir"/*; do
		test -d "$dir/.git" || continue
		repo_name="$(basename "$dir")"
		clone_url="$(git -C "$dir" remote get-url origin 2>/dev/null)" || clone_url=""

		if [ -n "$clone_url" ]; then
			entry="{ \"name\": \"$repo_name\", \"cloneURL\": \"$clone_url\" }"
		else
			entry="\"$repo_name\""
		fi

		if [ -z "$repos" ]; then
			repos="$entry"
		else
			repos="$repos,
$indent$entry"
		fi
	done

	if [ -z "$repos" ]; then
		echo '[
            { "name": "repo1", "cloneURL": "git@github.com:org/repo1.git" },
            { "name": "repo2", "cloneURL": "git@github.com:org/repo2.git" }
        ]'
	else
		echo "[
$indent$repos
        ]"
	fi
}

cs_stack_get_org_dir() {
	# if inside a git repo, go to parent (org level)
	# otherwise use current directory
	if git rev-parse --git-dir >/dev/null 2>&1; then
		repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" || repo_root="$(pwd)"
		dirname "$repo_root"
	else
		pwd
	fi
}

cs_stack_get_repos() {
	stack_name="$1"
	stacks_json="$2"

	# check if jq is available
	command -v jq >/dev/null 2>&1 || {
		>&2 echo "err: 'jq' is required to parse stacks.json"
		>&2 echo "install it with: brew install jq (macOS) or apt install jq (Linux)"
		exit 1
	}

	# extract repos array for the given stack
	# each repo entry is output on a separate line as JSON
	jq -c --arg name "$stack_name" '.stacks[$name][]' "$stacks_json" 2>/dev/null || {
		>&2 echo "err: failed to parse stacks.json or stack '$stack_name' not found"
		exit 1
	}
}

# Parse a repo entry from stacks.json, setting globals: repo_name, clone_url
# Entry can be: string (repo name or URL) or object {"name": "...", "cloneURL": "..."}
cs_stack_parse_repo_entry() {
	entry="$1"

	# reset globals
	repo_name=""
	clone_url=""

	if echo "$entry" | grep -q '^{'; then
		# JSON object: {"name": "repo", "cloneURL": "url"}
		repo_name="$(echo "$entry" | jq -r '.name')"
		clone_url="$(echo "$entry" | jq -r '.cloneURL // empty')"
	else
		# String value
		value="$(echo "$entry" | jq -r '.')"
		if echo "$value" | grep -qE '^(https?://|git@|ssh://)'; then
			clone_url="$value"
			repo_name="$(cs_repo_name_from_url "$value")"
		else
			repo_name="$value"
		fi
	fi

	test -n "$repo_name" || {
		>&2 echo "err: could not determine repo name from entry: $entry"
		exit 1
	}
}

# init a single repo for stack (clone/worktree + post-create)
cs_stack_init_repo() {
	create_mode="$1"
	r_name="$2"
	r_clone_url="$3"
	r_dest="$4"
	r_base="$5"
	branch_name="$6"

	echo "=== [$r_name] Clone/worktree ==="

	if [ "$create_mode" = "clone" ]; then
		# clone mode: always clone fresh
		test -n "$r_clone_url" || r_clone_url="$(git -C "$r_base" remote get-url origin)"
		cs_create_clone_core "$r_clone_url" "$r_dest" "$branch_name" || {
			echo "CLONE_FAILED"
			exit 1
		}
		echo "$r_name" > "$r_dest/.git/CODESPACE_IS_CLONE"
	else
		# worktree mode: clone base repo first if needed
		if [ ! -d "$r_base/.git" ]; then
			echo "Base repo not found, cloning: $r_clone_url -> $r_base"
			git clone "$r_clone_url" "$r_base" || {
				echo "CLONE_FAILED"
				exit 1
			}
		fi
		cs_create_worktree_core "$branch_name" "$r_base" "$r_dest" || {
			echo "CLONE_FAILED"
			exit 1
		}
	fi

	echo "=== [$r_name] Post-create ==="
	cd "$r_dest"
	cs_post_create "$r_dest" || {
		echo "POST_CREATE_FAILED"
		exit 1
	}

	echo "=== [$r_name] Done ==="
}

test -n "${CS_STACK_NO_RUN:-}" || {
	cs_stack_main "$@"
	exit $?
}
