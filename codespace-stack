#!/usr/bin/env bash

set -euo pipefail

# auto-detect agent environments and disable interactive prompts
test -n "${CS_NO_INTERACTIVE:-}" || {
	test -n "${CURSOR_AGENT:-}" || test -n "${CI:-}" && {
		export CS_NO_INTERACTIVE=1
	}
}

# codespace-stack: multi-repo codespace management

STACK_HELP="\
Usage:
codespace stack [create] <branch> [-s stack_name] [--clone|--worktree]

args:
  <branch>       branch name to create across all repos in the stack.

flags:
  -s, --stack <stack_name>
                 stack name from stacks.json (default: \"default\").

mode flags:
  --clone        force clone mode (fresh clones for all repos).
  --worktree     force worktree mode (create worktrees from local repos).

env vars:
  CS_STACK_DEFAULT_CREATE_MODE
                 default creation mode: \"worktree\" (default) or \"clone\".
  CS_NO_INTERACTIVE
                 if set, skip interactive prompts and use defaults.
                 inferred if CURSOR_AGENT, CI, other vars are set.

config:
  stacks.json    located in \$CODESPACE_CONFIG_ROOT/<org>/stacks.json
                 format: { \"version\": \"0\", \"stacks\": { \"stack-id\": [\"repo1\", \"repo2\"] } }
                 repo values:
                   - local repo names (siblings in file tree);
                   - clone URLs;
                   - objects: { \"name\": \"repo\", \"cloneURL\": \"url\" }.

examples:
  codespace stack        feature-x       # create \"default\" stack, create branches \"feature-x\" in all repos of stack
  codespace stack create feature-x       # same as above
  codespace stack feature-x -s full      # create stack from definition \"stack-id-2\" in stacks.json
  codespace stack feature-x --clone      # create clones, instead of worktrees
"

cs_stack_main() {
	# handle help
	case "${1:-}" in
		-h|--help)
			echo "$STACK_HELP"
			exit 0
			;;
		"")
			>&2 echo "$STACK_HELP"
			exit 1
			;;
	esac

	# dispatch subcommands
	cmd="$1"
	shift

	case "$cmd" in
		create)
			cs_stack_create "$@"
			;;
		*)
			# implied create
			cs_stack_create "$cmd" "$@"
			;;
	esac
}

cs_stack_create() {
	branch=""
	stack_name="default"
	mode_flag=""

	# parse arguments
	while [ $# -gt 0 ]; do
		case "$1" in
			-s)
				shift
				stack_name="${1:-}"
				test -n "$stack_name" || {
					>&2 echo "err: -s requires a stack name"
					exit 1
				}
				;;
			--clone)
				mode_flag="clone"
				;;
			--worktree)
				mode_flag="worktree"
				;;
			-*)
				>&2 echo "err: unknown option: $1"
				exit 1
				;;
			*)
				if [ -z "$branch" ]; then
					branch="$1"
				else
					>&2 echo "err: unexpected argument: $1"
					exit 1
				fi
				;;
		esac
		shift
	done

	test -n "$branch" || {
		>&2 echo "err: <branch> is required"
		>&2 echo "usage: codespace stack [create] <branch> [-s stack_name]"
		exit 1
	}

	# determine creation mode (priority: flag > env > default)
	if [ -n "$mode_flag" ]; then
		create_mode="$mode_flag"
	elif [ -n "${CS_STACK_DEFAULT_CREATE_MODE:-}" ]; then
		create_mode="$CS_STACK_DEFAULT_CREATE_MODE"
	else
		create_mode="worktree"
	fi

	# find stacks.json config
	stacks_json="$(cs_stack_find_config)"

	# get repos for the stack
	repos="$(cs_stack_get_repos "$stack_name" "$stacks_json")"
	test -n "$repos" || {
		>&2 echo "err: stack '$stack_name' not found or empty in $stacks_json"
		exit 1
	}

	# determine org directory (where repos live)
	org_dir="$(cs_stack_get_org_dir)"

	# create stack directory
	stack_dir="$org_dir/stack_$(cs_cleanpath "$branch")"
	if [ -d "$stack_dir" ]; then
		>&2 echo "err: stack directory already exists: $stack_dir"
		exit 1
	fi
	mkdir -p "$stack_dir"

	# process each repo
	echo "$repos" | while IFS= read -r repo_entry; do
		test -n "$repo_entry" || continue

		cs_stack_parse_repo_entry "$repo_entry"
		# repo_name and clone_url are set by cs_stack_parse_repo_entry

		repo_dest="$stack_dir/$repo_name"
		base_repo="$org_dir/$repo_name"

		# Resolve clone URL if needed (repo doesn't exist locally and no URL provided)
		if [ -z "$clone_url" ] && [ ! -d "$base_repo/.git" ]; then
			clone_url="$(cs_infer_clone_url "$repo_name" "$org_dir")" || {
				>&2 echo "err: repo '$repo_name' not found locally and couldn't infer clone URL"
				>&2 echo "options:"
				>&2 echo "  a) clone the repo: git clone <url> $base_repo"
				>&2 echo "  b) add clone URL to stacks.json"
				exit 1
			}
		fi

		if [ "$create_mode" = "clone" ]; then
			# clone mode: always clone fresh
			test -n "$clone_url" || clone_url="$(git -C "$base_repo" remote get-url origin)"
			cs_create_clone_core "$clone_url" "$repo_dest" "$branch"
			echo "$repo_name" > "$repo_dest/.git/CODESPACE_IS_CLONE"
		else
			# worktree mode: clone base repo first if needed
			if [ ! -d "$base_repo/.git" ]; then
				git clone "$clone_url" "$base_repo"
			fi
			cs_create_worktree_core "$branch" "$base_repo" "$repo_dest"
		fi

		# run post-create if available
		(cd "$repo_dest" && cs_post_create "$repo_dest") || true
	done

	# open in editor
	GUI_EDITOR="${GUI_EDITOR:-$EDITOR}"
	if [ -n "$GUI_EDITOR" ]; then
		(unset GIT_DIR GIT_WORK_TREE; "$GUI_EDITOR" --new-window "$stack_dir")
	else
		>&2 echo "warn: neither \$GUI_EDITOR nor \$EDITOR env var set, cannot open stack with editor"
	fi

	echo "$stack_dir"
}

cs_stack_find_config() {
	test -n "${CODESPACE_CONFIG_ROOT:-}" || {
		>&2 echo "err: env var '\$CODESPACE_CONFIG_ROOT' not set"
		exit 1
	}

	start_dir="$(cs_stack_get_org_dir)"
	current_dir="$start_dir"
	levels_up=0

	while true; do
		rel_path="$(realpath "$current_dir" --relative-to="$HOME" 2>/dev/null)" || rel_path="$current_dir"
		config_path="$CODESPACE_CONFIG_ROOT/$rel_path/stacks.json"

		if [ -f "$config_path" ]; then
			# if we went more than 1 level up, ask for confirmation
			if [ "$levels_up" -gt 1 ]; then
				if [ -n "${CS_NO_INTERACTIVE:-}" ]; then
					>&2 echo "found stacks.json $levels_up levels up at: $config_path (auto-accepting, CS_NO_INTERACTIVE set)"
				else
					>&2 printf "found stacks.json $levels_up levels up at: $config_path. use? [y/n] "
					read -r answer </dev/tty
					case "$answer" in
						y|Y|yes|Yes) ;;
						*)
							>&2 echo "aborted"
							exit 1
							;;
					esac
				fi
			fi
			echo "$config_path"
			return 0
		fi

		# check if we've reached home or root
		if [ "$current_dir" = "$HOME" ] || [ "$current_dir" = "/" ]; then
			break
		fi

		current_dir="$(dirname "$current_dir")"
		levels_up=$((levels_up + 1))
	done

	>&2 echo "err: stacks.json not found"
	>&2 echo "searched from: $start_dir"
	>&2 echo "expected location: \$CODESPACE_CONFIG_ROOT/<org>/stacks.json"
	exit 1
}

cs_stack_get_org_dir() {
	# if inside a git repo, go to parent (org level)
	# otherwise use current directory
	if git rev-parse --git-dir >/dev/null 2>&1; then
		repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" || repo_root="$(pwd)"
		dirname "$repo_root"
	else
		pwd
	fi
}

cs_stack_get_repos() {
	stack_name="$1"
	stacks_json="$2"

	# check if jq is available
	command -v jq >/dev/null 2>&1 || {
		>&2 echo "err: 'jq' is required to parse stacks.json"
		>&2 echo "install it with: brew install jq (macOS) or apt install jq (Linux)"
		exit 1
	}

	# extract repos array for the given stack
	# each repo entry is output on a separate line as JSON
	jq -c --arg name "$stack_name" '.stacks[$name][]' "$stacks_json" 2>/dev/null || {
		>&2 echo "err: failed to parse stacks.json or stack '$stack_name' not found"
		exit 1
	}
}

# Parse a repo entry from stacks.json, setting globals: repo_name, clone_url
# Entry can be: string (repo name or URL) or object {"name": "...", "cloneURL": "..."}
cs_stack_parse_repo_entry() {
	entry="$1"

	# reset globals
	repo_name=""
	clone_url=""

	if echo "$entry" | grep -q '^{'; then
		# JSON object: {"name": "repo", "cloneURL": "url"}
		repo_name="$(echo "$entry" | jq -r '.name')"
		clone_url="$(echo "$entry" | jq -r '.cloneURL // empty')"
	else
		# String value
		value="$(echo "$entry" | jq -r '.')"
		if echo "$value" | grep -qE '^(https?://|git@|ssh://)'; then
			clone_url="$value"
			repo_name="$(cs_repo_name_from_url "$value")"
		else
			repo_name="$value"
		fi
	fi

	test -n "$repo_name" || {
		>&2 echo "err: could not determine repo name from entry: $entry"
		exit 1
	}
}

test -n "${CS_STACK_NO_RUN:-}" || {
	cs_stack_main "$@"
	exit $?
}
