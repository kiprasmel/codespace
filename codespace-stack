#!/usr/bin/env bash

set -euo pipefail

DIRNAME="$(dirname "$(realpath "$0")")"

# shellcheck source=codespace-utils
source "$DIRNAME/codespace-utils"

# auto-detect agent environments and disable interactive prompts
test -n "${CS_NO_INTERACTIVE:-}" || {
	test -n "${CURSOR_AGENT:-}" || test -n "${CI:-}" && {
		export CS_NO_INTERACTIVE=1
	}
}

# codespace-stack: multi-repo codespace management

REPO_VALUES_INFO="\
- repo names (siblings in org directory)
- clone URLs
- objects: { \"name\": \"repo\", \"cloneURL\": \"url\" }"

STACK_HELP="\
Usage:
codespace stack [create] <branch> [-s stack_name] [-b base] [--clone|--worktree]
codespace stack init
codespace stack extend <name>[,<name2>]...

  <branch>       branch name to create across all repos in the stack.
  <name>         stack config name from stacks.json, or repo name from org directory.

optional flags:
  -b, --base <branch>
                 base branch to create from (default: remote HEAD).
  -s, --stack <stack_name>
                 stack config name from stacks.json (default: \"default\").
  --clone        force clone mode (fresh clones for all repos).
  --worktree     force worktree mode (create worktrees from local repos).


env vars:
  CS_STACK_DEFAULT_CREATE_MODE
                 default creation mode: \"worktree\" (default) or \"clone\".
  CS_NO_INTERACTIVE
                 if set, skip interactive prompts and use defaults.
                 inferred if CURSOR_AGENT, CI, other vars are set.


config:
  stacks.json    located in \$CODESPACE_CONFIG_ROOT/<org>/stacks.json
                 format: { \"version\": \"0\", \"stacks\": { \"stack-id\": [\"repo1\", \"repo2\"] } }
                 repo values:
$(echo "$REPO_VALUES_INFO" | sed 's/^/                   /')


sub-commands:
  create <branch> [-s stack_name] [-b base] [--clone|--worktree]
                  create a new stack with repos from a stack configuration.
                  \"create\" is implied if omitted.

  init            create a stacks.json configuration file.

  extend <name>[,<name2>]...
                  extend current stack with repos from stack configs or repo names.
                  first checks stacks.json, then falls back to repos in <org> directory.
                  must be run from within an existing stack directory (or child).
                  uses the same creation mode (clone/worktree) as existing repos.


examples:
  codespace stack init                   # create stacks.json config file
  codespace stack        feature-x       # create \"default\" stack, branches \"feature-x\" in all repos
  codespace stack create feature-x       # same as above
  codespace stack feature-x -s full      # create stack from \"full\" config in stacks.json
  codespace stack feature-x -b develop   # create stack from \"develop\" branch instead of default
  codespace stack feature-x --clone      # create clones, instead of worktrees
  codespace stack extend be              # add repos from \"be\" stack config
  codespace stack extend be,infra        # add repos from \"be\" and \"infra\" stack configs
  codespace stack extend backend         # add \"backend\" repo directly
"

cs_stack_main() {
	# handle help
	case "${1:-}" in
		-h|--help)
			echo "$STACK_HELP"
			exit 0
			;;
		"")
			>&2 echo "$STACK_HELP"
			exit 1
			;;
	esac

	# dispatch subcommands
	cmd="$1"
	shift

	case "$cmd" in
		create)
			cs_stack_create "$@"
			;;
		init)
			cs_stack_init "$@"
			;;
		init-repo)
			# internal subcommand used by cs_stack_create for parallel repo init
			cs_stack_init_repo "$@"
			;;
		extend)
			cs_stack_extend "$@"
			;;
		*)
			# implied create
			cs_stack_create "$cmd" "$@"
			;;
	esac
}

# Parse and validate create arguments
# Sets globals: branch, stack_name, create_mode, base_branch
cs_stack_create_parse_args() {
	branch=""
	stack_name="default"
	base_branch=""
	local mode_flag=""

	while [ $# -gt 0 ]; do
		case "$1" in
			-s|--stack)
				shift
				stack_name="${1:-}"
				test -n "$stack_name" || {
					>&2 echo "err: -s requires a stack name"
					exit 1
				}
				;;
			-b|--base)
				shift
				base_branch="${1:-}"
				test -n "$base_branch" || {
					>&2 echo "err: -b requires a base branch"
					exit 1
				}
				;;
			--clone)
				mode_flag="clone"
				;;
			--worktree)
				mode_flag="worktree"
				;;
			-*)
				>&2 echo "err: unknown option: $1"
				exit 1
				;;
			*)
				if [ -z "$branch" ]; then
					branch="$1"
				else
					>&2 echo "err: unexpected argument: $1"
					exit 1
				fi
				;;
		esac
		shift
	done

	test -n "$branch" || {
		>&2 echo "err: <branch> is required"
		>&2 echo "usage: codespace stack [create] <branch> [-s stack_name]"
		exit 1
	}

	# determine creation mode (priority: flag > env > default)
	if [ -n "$mode_flag" ]; then
		create_mode="$mode_flag"
	elif [ -n "${CS_STACK_DEFAULT_CREATE_MODE:-}" ]; then
		create_mode="$CS_STACK_DEFAULT_CREATE_MODE"
	else
		create_mode="worktree"
	fi
}

# Setup stack directory structure
# Uses globals: branch, org_dir
# Sets globals: stack_dir, logs_dir
cs_stack_create_setup_dirs() {
	stack_dir="$org_dir/stack_$(cs_cleanpath "$branch")"
	if [ -d "$stack_dir" ]; then
		>&2 echo "err: stack directory already exists: $stack_dir"
		exit 1
	fi
	mkdir -p "$stack_dir"

	logs_dir="$stack_dir/.stack-init-logs"
	mkdir -p "$logs_dir"
}

# Setup tmux session if available
# Uses globals: branch, logs_dir
# Sets globals: use_tmux, tmux_session
cs_stack_create_setup_tmux() {
	use_tmux=""
	tmux_session=""
	if [ -z "${CS_NO_INTERACTIVE:-}" ] && command -v tmux >/dev/null 2>&1; then
		use_tmux=1
		tmux_session="stack-init-$(cs_cleanpath "$branch")"
		# kill existing session if present (e.g. from previous extend that was interrupted)
		tmux kill-session -t "$tmux_session" 2>/dev/null || true
		# create session with placeholder window (will be killed after repo windows are created)
		tmux new-session -d -s "$tmux_session" -n "_placeholder"
		# increase scrollback buffer so user can see all init logs
		tmux set-option -t "$tmux_session" history-limit 50000
		# enable mouse mode for terminal scrolling
		tmux set-option -t "$tmux_session" mouse on
	fi
}

# Pre-parse all repos into arrays
# Args: $1 = repos (newline-separated JSON entries)
# Uses globals: stack_dir, org_dir
# Sets globals: repo_names[], repo_clone_urls[], repo_dests[], repo_base_repos[]
cs_stack_create_prepare_repos() {
	local repos="$1"

	repo_names=()
	repo_clone_urls=()
	repo_dests=()
	repo_base_repos=()

	while IFS= read -r repo_entry; do
		test -n "$repo_entry" || continue

		cs_stack_parse_repo_entry "$repo_entry"
		# repo_name and clone_url are set by cs_stack_parse_repo_entry

		local local_repo_name="$repo_name"
		local local_clone_url="$clone_url"
		local repo_dest="$stack_dir/$local_repo_name"
		local base_repo="$org_dir/$local_repo_name"

		# Resolve clone URL if needed (repo doesn't exist locally and no URL provided)
		if [ -z "$local_clone_url" ] && [ ! -d "$base_repo/.git" ]; then
			local_clone_url="$(cs_infer_clone_url "$local_repo_name" "$org_dir")" || {
				>&2 echo "err: repo '$local_repo_name' not found locally and couldn't infer clone URL"
				>&2 echo "options:"
				>&2 echo "  a) clone the repo: git clone <url> $base_repo"
				>&2 echo "  b) add clone URL to stacks.json"
				exit 1
			}
		fi

		repo_names+=("$local_repo_name")
		repo_clone_urls+=("$local_clone_url")
		repo_dests+=("$repo_dest")
		repo_base_repos+=("$base_repo")
	done <<< "$repos"
}

# Spawn parallel repo init jobs
# Uses globals: create_mode, repo_names[], repo_clone_urls[], repo_dests[],
#               repo_base_repos[], logs_dir, use_tmux, tmux_session, branch, base_branch
# Sets globals: repo_pids[]
cs_stack_create_spawn_jobs() {
	>&2 echo "==> initializing repos (${#repo_names[@]} repos, mode: $create_mode)"
	>&2 echo "  logs: \"$logs_dir\""
	if [ -n "$use_tmux" ]; then
		>&2 echo "  preview with:"
		echo "  tmux attach -t $tmux_session"
	fi

	repo_pids=()
	for i in "${!repo_names[@]}"; do
		local r_name="${repo_names[$i]}"
		local r_clone_url="${repo_clone_urls[$i]}"
		local r_dest="${repo_dests[$i]}"
		local r_base="${repo_base_repos[$i]}"
		local log_file="$logs_dir/$r_name.log"

		if [ -n "$use_tmux" ]; then
			# tmux mode: create window with shell, then send init command
			# after init, open log in less with mouse support for scrolling (strip ^M with col -b)
			tmux new-window -t "$tmux_session" -n "$r_name"
			tmux send-keys -t "$tmux_session:$r_name" \
				"'$DIRNAME/codespace-stack' init-repo '$create_mode' '$r_name' '$r_clone_url' '$r_dest' '$r_base' '$branch' '$base_branch' 2>&1 | tee '$log_file' && { echo '=== [$r_name] Init complete. Press q to exit, or scroll with mouse ==='; col -b < '$log_file' | less -R --mouse +G; }" Enter
			# kill placeholder window after first real window is created
			tmux kill-window -t "$tmux_session:_placeholder" 2>/dev/null || true
		else
			# no tmux: background job with file logging
			(
				"$DIRNAME/codespace-stack" init-repo "$create_mode" "$r_name" "$r_clone_url" "$r_dest" "$r_base" "$branch" "$base_branch"
			) >"$log_file" 2>&1 &
			repo_pids+=($!)
		fi
	done
}

# Wait for jobs and print summary
# Args: $1 = mode ("create" or "extend")
# Uses globals: use_tmux, tmux_session, repo_names[], logs_dir, repo_pids[], stack_dir
cs_stack_create_wait_and_summarize() {
	local mode="${1:-create}"
	local failures=()
	if [ -n "$use_tmux" ]; then
		cs_stack_tmux_wait "$logs_dir" "${repo_names[@]}"
		# check logs for failures
		for i in "${!repo_names[@]}"; do
			local r_name="${repo_names[$i]}"
			local log_file="$logs_dir/$r_name.log"
			if [ -f "$log_file" ] && grep -qE "CLONE_FAILED|POST_CREATE_FAILED" "$log_file"; then
				failures+=("$r_name")
			fi
		done
	else
		for i in "${!repo_pids[@]}"; do
			local pid="${repo_pids[$i]}"
			local r_name="${repo_names[$i]}"
			if ! wait "$pid"; then
				failures+=("$r_name")
			fi
		done
	fi

	local verb
	if [ "$mode" = "extend" ]; then
		verb="extended"
	else
		verb="created"
	fi

	echo
	if [ ${#failures[@]} -gt 0 ]; then
		>&2 echo "==> stack $verb with errors:"
		>&2 echo "  failed repos: ${failures[*]}"
		>&2 echo "  logs: $logs_dir"
		if [ -n "$use_tmux" ]; then
			>&2 echo "    tmux session: tmux attach -t $tmux_session"
		fi
	else
		>&2 echo "==> stack $verb successfully"
		# clean up logs on success (unless DEBUG is set)
		if [ -z "${DEBUG:-}" ]; then
			rm -rf "$logs_dir"
		else
			>&2 echo "  logs: $logs_dir"
		fi
		# tmux session is kept alive for user to attach and inspect
	fi

	# print summary
	if [ "$mode" = "extend" ]; then
		echo "  $stack_dir"
		for r_name in "${repo_names[@]}"; do
			echo "  + $r_name"
		done
	else
		echo "  $stack_dir"
	fi
	echo ""
}

# Open editor for the stack
# Uses globals: stack_dir
cs_stack_create_open_editor() {
	>&2 echo "==> opening editor"
	GUI_EDITOR="${GUI_EDITOR:-$EDITOR}"
	if [ -n "$GUI_EDITOR" ]; then
		(unset GIT_DIR GIT_WORK_TREE; "$GUI_EDITOR" --new-window "$stack_dir") &
	else
		>&2 echo "warn: neither \$GUI_EDITOR nor \$EDITOR env var set, cannot open stack with editor"
	fi
}

cs_stack_create() {
	cs_stack_create_parse_args "$@"

	# find stacks.json config and org directory
	# cs_stack_find_config outputs two lines: config_path and org_dir
	config_output="$(cs_stack_find_config)"
	stacks_json="$(echo "$config_output" | head -n1)"
	org_dir="$(echo "$config_output" | tail -n1)"

	# get repos for the stack
	repos="$(cs_stack_get_repos "$stack_name" "$stacks_json")"
	test -n "$repos" || {
		>&2 echo "err: stack '$stack_name' not found or empty in $stacks_json"
		exit 1
	}

	cs_stack_create_setup_dirs
	cs_stack_create_setup_tmux
	cs_stack_create_prepare_repos "$repos"
	cs_stack_create_open_editor
	cs_stack_create_spawn_jobs
	cs_stack_create_wait_and_summarize "create"
}

# extend an existing stack with repos from other stack configurations or repo names
cs_stack_extend() {
	# parse arguments
	local extend_args="${1:-}"
	test -n "$extend_args" || {
		>&2 echo "err: <stack_name|repo_name> is required"
		>&2 echo "usage: codespace stack extend <stack_name>[,<stack_name2>]..."
		>&2 echo "  accepts stack config names from stacks.json, or repo names from org directory"
		exit 1
	}

	# detect current stack
	local detect_output
	detect_output="$(cs_stack_detect_current)" || {
		>&2 echo "err: not inside a stack directory"
		>&2 echo "hint: run this command from within a stack_* directory or a repo inside one"
		exit 1
	}

	stack_dir="$(echo "$detect_output" | sed -n '1p')"
	branch="$(echo "$detect_output" | sed -n '2p')"
	org_dir="$(echo "$detect_output" | sed -n '3p')"

	>&2 echo "==> extending stack: $stack_dir"
	>&2 echo "  branch: $branch"

	# detect creation mode from existing repos
	create_mode="$(cs_stack_detect_mode "$stack_dir")"
	>&2 echo "  mode: $create_mode (auto-detected from existing repos)"

	# base_branch not used for extend (uses default branch of each repo)
	base_branch=""

	# find stacks.json config (optional for repo-name mode)
	local stacks_json=""
	if [ -n "${CODESPACE_CONFIG_ROOT:-}" ]; then
		local rel_path
		rel_path="$(realpath "$org_dir" --relative-to="$HOME" 2>/dev/null)" || rel_path="$org_dir"
		stacks_json="$CODESPACE_CONFIG_ROOT/$rel_path/stacks.json"
		test -f "$stacks_json" || stacks_json=""
	fi

	# get list of existing repos/directories in the stack
	local existing_repos=()
	for repo_dir in "$stack_dir"/*; do
		test -d "$repo_dir" || continue
		existing_repos+=("$(basename "$repo_dir")")
	done

	# collect repos from all specified stack configs or repo names
	local all_new_repos=""
	IFS=',' read -ra arg_names <<< "$extend_args"
	for arg_name in "${arg_names[@]}"; do
		# trim whitespace
		arg_name="$(echo "$arg_name" | xargs)"
		test -n "$arg_name" || continue

		local repos=""
		local source_type=""

		# first, try as stack config name
		if [ -n "$stacks_json" ]; then
			repos="$(cs_stack_get_repos "$arg_name" "$stacks_json" 2>/dev/null)" && source_type="stack"
		fi

		# if not found as stack config, try as repo name in org directory
		if [ -z "$source_type" ]; then
			if [ -d "$org_dir/$arg_name/.git" ]; then
				# repo exists locally - create a simple repo entry
				repos="\"$arg_name\""
				source_type="repo"
			else
				# check if we can infer clone URL
				local inferred_url
				if inferred_url="$(cs_infer_clone_url "$arg_name" "$org_dir" 2>/dev/null)"; then
					repos="{ \"name\": \"$arg_name\", \"cloneURL\": \"$inferred_url\" }"
					source_type="repo (inferred)"
				else
					>&2 echo "err: '$arg_name' not found as stack config or repo in $org_dir"
					exit 1
				fi
			fi
		fi

		>&2 echo "  adding from $source_type: $arg_name"

		# filter out repos that already exist
		while IFS= read -r repo_entry; do
			test -n "$repo_entry" || continue

			cs_stack_parse_repo_entry "$repo_entry"
			# repo_name is set by cs_stack_parse_repo_entry

			# check if already exists
			local exists=""
			for existing in "${existing_repos[@]}"; do
				if [ "$existing" = "$repo_name" ]; then
					exists=1
					break
				fi
			done

			if [ -n "$exists" ]; then
				>&2 echo "    skipping '$repo_name' (already in stack)"
			else
				if [ -z "$all_new_repos" ]; then
					all_new_repos="$repo_entry"
				else
					all_new_repos="$all_new_repos"$'\n'"$repo_entry"
				fi
				# add to existing list to avoid duplicates across configs
				existing_repos+=("$repo_name")
			fi
		done <<< "$repos"
	done

	# check if there are any new repos to add
	test -n "$all_new_repos" || {
		>&2 echo "==> no new repos to add (all already in stack)"
		exit 0
	}

	# setup logs directory
	logs_dir="$stack_dir/.stack-extend-logs"
	mkdir -p "$logs_dir"

	# setup tmux if available
	cs_stack_create_setup_tmux

	# prepare and spawn jobs for new repos
	cs_stack_create_prepare_repos "$all_new_repos"
	cs_stack_create_spawn_jobs
	cs_stack_create_wait_and_summarize "extend"
}

# Wait for tmux repo init jobs to complete by polling log files
# Args: logs_dir, repo_names...
cs_stack_tmux_wait() {
	local wait_logs_dir="$1"
	shift

	# poll until all repos have completed (check for Done or failure markers in logs)
	while true; do
		remaining=0
		for r_name in "$@"; do
			local log_file="$wait_logs_dir/$r_name.log"
			# check if log file exists and contains completion marker
			# (pattern is lenient to handle buffering/whitespace variations)
			if [ -f "$log_file" ]; then
				if grep -qE "\[$r_name\] Done ===|CLONE_FAILED|POST_CREATE_FAILED" "$log_file"; then
					continue  # this repo is done
				fi
			fi
			remaining=$((remaining + 1))
		done
		[ "$remaining" -eq 0 ] && break
		sleep 1
	done
}

# Find stacks.json config by walking up from org_dir
# Outputs two lines:
#   Line 1: config file path
#   Line 2: org directory where config was found (use this for stack creation)
cs_stack_find_config() {
	test -n "${CODESPACE_CONFIG_ROOT:-}" || {
		>&2 echo "err: env var '\$CODESPACE_CONFIG_ROOT' not set"
		exit 1
	}

	start_dir="$(cs_stack_get_org_dir)"
	current_dir="$start_dir"
	levels_up=0

	while true; do
		rel_path="$(realpath "$current_dir" --relative-to="$HOME" 2>/dev/null)" || rel_path="$current_dir"
		config_path="$CODESPACE_CONFIG_ROOT/$rel_path/stacks.json"

		if [ -f "$config_path" ]; then
			# if we went more than 1 level up, ask for confirmation
			if [ "$levels_up" -gt 1 ]; then
				if [ -n "${CS_NO_INTERACTIVE:-}" ]; then
					>&2 echo "found stacks.json $levels_up levels up, stack will be created in: $current_dir (auto-accepting, CS_NO_INTERACTIVE set)"
				else
					>&2 printf "found stacks.json $levels_up levels up, stack will be created in: $current_dir. use? [y/n] "
					read -r answer </dev/tty
					case "$answer" in
						y|Y|yes|Yes) ;;
						*)
							>&2 echo "aborted"
							exit 1
							;;
					esac
				fi
			fi
			# output config path and the matched org directory
			echo "$config_path"
			echo "$current_dir"
			return 0
		fi

		# check if we've reached home or root
		if [ "$current_dir" = "$HOME" ] || [ "$current_dir" = "/" ]; then
			break
		fi

		current_dir="$(dirname "$current_dir")"
		levels_up=$((levels_up + 1))
	done

	>&2 echo "err: stacks.json not found"
	>&2 echo "searched from: $start_dir"
	>&2 echo "expected location: \$CODESPACE_CONFIG_ROOT/<org>/stacks.json"
	>&2 echo "hint: run 'codespace stack init' to create one"
	exit 1
}

cs_stack_init() {
	test -n "${CODESPACE_CONFIG_ROOT:-}" || {
		>&2 echo "err: env var '\$CODESPACE_CONFIG_ROOT' not set"
		exit 1
	}

	# check if a config already exists (possibly at a higher level)
	if config_output="$(cs_stack_find_config 2>/dev/null)"; then
		existing_config="$(echo "$config_output" | head -n1)"
		existing_org_dir="$(echo "$config_output" | tail -n1)"
		>&2 echo "stacks.json already exists at:"
		echo "$existing_config"
		>&2 echo "(org directory: $existing_org_dir)"
		exit 0
	fi

	# no config found - create one at the current org level
	org_dir="$(cs_stack_get_org_dir)"
	rel_path="$(realpath "$org_dir" --relative-to="$HOME" 2>/dev/null)" || rel_path="$org_dir"
	config_dir="$CODESPACE_CONFIG_ROOT/$rel_path"
	config_path="$config_dir/stacks.json"

	# discover repos in org directory for template
	repos_json="$(cs_stack_discover_repos "$org_dir")"

	mkdir -p "$config_dir"

	# create template stacks.json
	cat > "$config_path" << EOF
{
    "version": "0",
    "stacks": {
        "default": $repos_json
    }
}
EOF

	info="\
edit the file to configure your stacks:
  - \"default\" stack contains discovered repos from: $org_dir
  - add more stacks as needed
  - repo values can be:
$(echo "$REPO_VALUES_INFO" | sed 's/^/      /')

created stacks.json at:
$config_path\
"

	echo "$info"
}

# Discover repos in org directory and return as JSON array
cs_stack_discover_repos() {
	org_dir="$1"
	repos=""
	indent="            "  # 12 spaces for array items

	for dir in "$org_dir"/*; do
		test -d "$dir/.git" || continue
		repo_name="$(basename "$dir")"
		clone_url="$(git -C "$dir" remote get-url origin 2>/dev/null)" || clone_url=""

		if [ -n "$clone_url" ]; then
			entry="{ \"name\": \"$repo_name\", \"cloneURL\": \"$clone_url\" }"
		else
			entry="\"$repo_name\""
		fi

		if [ -z "$repos" ]; then
			repos="$entry"
		else
			repos="$repos,
$indent$entry"
		fi
	done

	if [ -z "$repos" ]; then
		echo '[
            { "name": "repo1", "cloneURL": "git@github.com:org/repo1.git" },
            { "name": "repo2", "cloneURL": "git@github.com:org/repo2.git" }
        ]'
	else
		echo "[
$indent$repos
        ]"
	fi
}

cs_stack_get_org_dir() {
	# if inside a git repo, go to parent (org level)
	# otherwise use current directory
	if git rev-parse --git-dir >/dev/null 2>&1; then
		# use cs_abs_path_base_repo to properly resolve through worktrees
		repo_root="$(cs_abs_path_base_repo)"
		dirname "$repo_root"
	else
		pwd
	fi
}

# detect if we're inside a stack directory by walking up the tree
# outputs three lines:
#   line 1: stack directory path
#   line 2: branch name (extracted from stack_<branch> pattern)
#   line 3: org directory (parent of stack)
# returns non-zero if not inside a stack
cs_stack_detect_current() {
	local current_dir
	current_dir="$(pwd)"

	while true; do
		local dir_name
		dir_name="$(basename "$current_dir")"

		# check if directory name matches stack_* pattern
		if [[ "$dir_name" == stack_* ]]; then
			local stack_dir="$current_dir"
			local org_dir
			org_dir="$(dirname "$current_dir")"
			# extract branch name by removing "stack_" prefix
			local branch="${dir_name#stack_}"

			echo "$stack_dir"
			echo "$branch"
			echo "$org_dir"
			return 0
		fi

		# check if we've reached root
		if [ "$current_dir" = "/" ]; then
			break
		fi

		current_dir="$(dirname "$current_dir")"
	done

	return 1
}

# detect creation mode of existing stack by checking for clone markers
# outputs: "clone" or "worktree"
cs_stack_detect_mode() {
	local stack_dir="$1"

	# check each repo in the stack for clone marker
	for repo_dir in "$stack_dir"/*; do
		test -d "$repo_dir/.git" || continue
		if [ -f "$repo_dir/.git/CODESPACE_IS_CLONE" ]; then
			echo "clone"
			return 0
		fi
	done

	# default to worktree if no clone markers found
	echo "worktree"
}

cs_stack_get_repos() {
	stack_name="$1"
	stacks_json="$2"

	# check if jq is available
	command -v jq >/dev/null 2>&1 || {
		>&2 echo "err: 'jq' is required to parse stacks.json"
		>&2 echo "install it with: brew install jq (macOS) or apt install jq (Linux)"
		exit 1
	}

	# extract repos array for the given stack
	# each repo entry is output on a separate line as JSON
	jq -c --arg name "$stack_name" '.stacks[$name][]' "$stacks_json" 2>/dev/null || {
		>&2 echo "err: failed to parse stacks.json or stack '$stack_name' not found"
		exit 1
	}
}

# Parse a repo entry from stacks.json, setting globals: repo_name, clone_url
# Entry can be: string (repo name or URL) or object {"name": "...", "cloneURL": "..."}
cs_stack_parse_repo_entry() {
	entry="$1"

	# reset globals
	repo_name=""
	clone_url=""

	if echo "$entry" | grep -q '^{'; then
		# JSON object: {"name": "repo", "cloneURL": "url"}
		repo_name="$(echo "$entry" | jq -r '.name')"
		clone_url="$(echo "$entry" | jq -r '.cloneURL // empty')"
	else
		# String value
		value="$(echo "$entry" | jq -r '.')"
		if echo "$value" | grep -qE '^(https?://|git@|ssh://)'; then
			clone_url="$value"
			repo_name="$(cs_repo_name_from_url "$value")"
		else
			repo_name="$value"
		fi
	fi

	test -n "$repo_name" || {
		>&2 echo "err: could not determine repo name from entry: $entry"
		exit 1
	}
}

# init a single repo for stack (clone/worktree + post-create)
cs_stack_init_repo() {
	create_mode="$1"
	r_name="$2"
	r_clone_url="$3"
	r_dest="$4"
	r_base="$5"
	branch_name="$6"
	r_base_branch="${7:-}"

	echo "=== [$r_name] Clone/worktree ==="

	# check if destination already exists
	if [ -d "$r_dest" ]; then
		echo "err: destination already exists: $r_dest"
		echo "CLONE_FAILED"
		exit 1
	fi

	if [ "$create_mode" = "clone" ]; then
		# clone mode: always clone fresh
		test -n "$r_clone_url" || r_clone_url="$(git -C "$r_base" remote get-url origin)"
		cs_create_clone_core "$r_clone_url" "$r_dest" "$branch_name" || {
			echo "CLONE_FAILED"
			exit 1
		}
		echo "$r_name" > "$r_dest/.git/CODESPACE_IS_CLONE"
	else
		# worktree mode: clone base repo first if needed
		if [ ! -d "$r_base/.git" ]; then
			echo "Base repo not found, cloning: $r_clone_url -> $r_base"
			git clone "$r_clone_url" "$r_base" || {
				echo "CLONE_FAILED"
				exit 1
			}
		fi
		# prune stale worktree references (e.g. from improperly removed worktrees)
		git -C "$r_base" worktree prune
		cs_create_worktree_core "$branch_name" "$r_base" "$r_dest" "$r_base_branch" || {
			echo "CLONE_FAILED"
			exit 1
		}
	fi

	echo "=== [$r_name] Post-create ==="
	cd "$r_dest" || {
		echo "POST_CREATE_FAILED"
		exit 1
	}
	cs_post_create "$r_dest" || {
		echo "POST_CREATE_FAILED"
		exit 1
	}

	echo "=== [$r_name] Done ==="
}

test -n "${CS_STACK_NO_RUN:-}" || {
	cs_stack_main "$@"
	exit $?
}
